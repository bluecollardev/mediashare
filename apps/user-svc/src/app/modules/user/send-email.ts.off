// TODO: Move the mailing part out of here!
/* @Post('send-email')
@ApiQuery({ name: 'userId', required: true, description: 'The userId of the currently logged in user' })
@ApiQuery({ name: 'email', required: true, description: 'The email address to send the invitation to' })
async sendEmail(@Query('userId') userId, @Query('email') email, @Res() res: Response) {
  try {
    if (!userId || !email) {
      return res.status(HttpStatus.BAD_REQUEST).json({
        statusCode: 400,
      });
    }

    // Does email already exist?
    // Note that we can have multiple matching users to a single email, as a single user can currently have
    // multiple accounts with different user names corresponding to a single email address.
    // We do this so that I can personally test this with multiple accounts, I don't want to have to create a bunch of
    // fake email addresses to test when I can just use my own existing accounts.
    // In the future, we'll probably want to only allow a single account per email. To do this updates are also required
    // in our AWS Cognito user pool.
    const matchingUsers = await this.userConnectionService.findUsersByEmail(email);
    const hasMatchingUsers = Array.isArray(matchingUsers) && matchingUsers.length > 0;

    const emailSubject = process.env['INVITATION_EMAIL_SUBJECT'];
    const emailFrom = process.env['INVITATION_EMAIL_SENDER'];

    const createAndSendEmail = async (email) => {
      const currentUser: ProfileDto = await this.userService.getUserById(userId);
      const mail = {
        to: email,
        subject: emailSubject,
        from: emailFrom,
        html: renderInvitationEmailTemplate(currentUser, email),
      };
      console.log(`Sending email invitation on behalf on ${currentUser.email} [${userId}] to: ${email} `);
      const result = await this.userConnectionService.sendEmail(mail);
    };

    // Does the user receiving the invitation already have an account?
    if (hasMatchingUsers) {
      // If matching users we need to send an email invitation
      // Get all existing user connections
      const currentUserConnections = await this.userConnectionService.findConnections(userId);
      // For each matching user account, send out an email invitation
      const invitationsToSend = matchingUsers
        // A user cannot be both the sender and the recipient of an invitation
        // TODO: Throw some kind of validation error if this occurs so the user can react to it
        .filter((invitee) => userId !== invitee._id.toString())
        // Remove any recipients that are already connections
        // .filter((invitee) => !currentUserConnections.find((connection) => connection.connectionId === invitee._id))
        // And send out the emails
        .map((invitee) => createAndSendEmail(invitee.email));

      await Promise.all(invitationsToSend);
      return res.status(HttpStatus.OK).json({
        statusCode: 200,
      });
    } else {
      await createAndSendEmail(email);
      return res.status(HttpStatus.OK).json({
        statusCode: 200,
      });
    }
  } catch (err) {
    console.log(err);
    return res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({
      statusCode: 500,
    });
  }
}

// TODO: MOVE THIS OUT?
@UseGuards(AuthenticationGuard)
@Get('media-items')
// @UserGetResponse({ type: MediaItemResponseDto, isArray: true })
async getUserMediaItems(@Res() res: Response, @GetUser('_id') userId: ObjectId) {
  /*const result = await this.mediaItemService.getByUserId(userId);*/
  return res.send('OK');
}*/
